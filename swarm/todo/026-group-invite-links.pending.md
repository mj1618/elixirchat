# Task: Group Invite Links

## Description
Allow group chat creators/members to generate shareable invite links that anyone can use to join the group. This is a common feature in chat applications like Telegram, Discord, and WhatsApp that makes it easy to invite multiple people to a group without having to search and add each person individually. The link can be shared externally (email, other apps) and provides a frictionless way to grow group membership.

## Requirements
- Group members can generate an invite link for their group
- Invite links are unique, unguessable tokens (e.g., `/join/abc123xyz`)
- Anyone with a valid link can join the group (must be logged in)
- Links can be revoked/regenerated by any group member
- Optional: links can have an expiration time
- Optional: links can have a maximum uses limit
- The General group should not have invite links (everyone is auto-added)
- Clicking an invalid/expired link shows an appropriate error message

## Implementation Steps

1. **Create GroupInvite schema and migration** (`lib/elixirchat/chat/group_invite.ex`):
   - Fields: `token`, `conversation_id`, `created_by_id`, `expires_at`, `max_uses`, `use_count`
   - Unique constraint on token
   - Belongs to Conversation and User (creator)

2. **Create database migration**:
   ```bash
   mix ecto.gen.migration create_group_invites
   ```
   ```elixir
   create table(:group_invites) do
     add :token, :string, null: false
     add :expires_at, :utc_datetime
     add :max_uses, :integer
     add :use_count, :integer, default: 0
     add :conversation_id, references(:conversations, on_delete: :delete_all), null: false
     add :created_by_id, references(:users, on_delete: :nilify_all), null: false
     timestamps()
   end

   create unique_index(:group_invites, [:token])
   create index(:group_invites, [:conversation_id])
   ```

3. **Add invite functions to Chat context** (`lib/elixirchat/chat.ex`):
   - `create_group_invite/2` - Create invite for a group (conversation_id, user_id)
   - `create_group_invite/3` - With options (expires_at, max_uses)
   - `get_invite_by_token/1` - Get invite by token
   - `get_group_invite/1` - Get existing active invite for a group
   - `use_invite/2` - Use invite to join group (token, user_id)
   - `revoke_invite/2` - Revoke/delete an invite
   - `is_invite_valid?/1` - Check if invite is still usable

4. **Create JoinGroupLive** (`lib/elixirchat_web/live/join_group_live.ex`):
   - Handle `/join/:token` route
   - Show group name and member count
   - "Join Group" button for logged-in users
   - Redirect to login if not authenticated
   - Show error for invalid/expired links
   - Redirect to group chat after joining

5. **Update Router** (`lib/elixirchat_web/router.ex`):
   - Add route `/join/:token` -> JoinGroupLive

6. **Update ChatLive** (`lib/elixirchat_web/live/chat_live.ex`):
   - Add "Get Invite Link" button in group chat header/settings
   - Modal to show/copy invite link
   - Option to regenerate link
   - Display link expiration info if set

7. **Add copy-to-clipboard functionality**:
   - JavaScript hook to copy invite link
   - Visual feedback when copied

## Technical Details

### GroupInvite Schema
```elixir
defmodule Elixirchat.Chat.GroupInvite do
  use Ecto.Schema
  import Ecto.Changeset

  alias Elixirchat.Accounts.User
  alias Elixirchat.Chat.Conversation

  schema "group_invites" do
    field :token, :string
    field :expires_at, :utc_datetime
    field :max_uses, :integer
    field :use_count, :integer, default: 0

    belongs_to :conversation, Conversation
    belongs_to :created_by, User

    timestamps()
  end

  def changeset(invite, attrs) do
    invite
    |> cast(attrs, [:token, :conversation_id, :created_by_id, :expires_at, :max_uses, :use_count])
    |> validate_required([:token, :conversation_id, :created_by_id])
    |> unique_constraint(:token)
    |> foreign_key_constraint(:conversation_id)
    |> foreign_key_constraint(:created_by_id)
  end

  @doc """
  Generates a secure random token for invite links.
  """
  def generate_token do
    :crypto.strong_rand_bytes(16) |> Base.url_encode64(padding: false)
  end
end
```

### Chat Context Functions
```elixir
alias Elixirchat.Chat.GroupInvite

def create_group_invite(conversation_id, user_id, opts \\ []) do
  conversation = get_conversation!(conversation_id)

  cond do
    conversation.type != "group" ->
      {:error, :not_a_group}

    conversation.is_general == true ->
      {:error, :cannot_invite_to_general}

    !member?(conversation_id, user_id) ->
      {:error, :not_a_member}

    true ->
      # Revoke any existing invite first (one active invite per group)
      revoke_existing_invite(conversation_id)

      attrs = %{
        token: GroupInvite.generate_token(),
        conversation_id: conversation_id,
        created_by_id: user_id,
        expires_at: Keyword.get(opts, :expires_at),
        max_uses: Keyword.get(opts, :max_uses)
      }

      %GroupInvite{}
      |> GroupInvite.changeset(attrs)
      |> Repo.insert()
  end
end

def get_invite_by_token(token) do
  Repo.get_by(GroupInvite, token: token)
  |> Repo.preload([:conversation, :created_by])
end

def get_group_invite(conversation_id) do
  from(i in GroupInvite,
    where: i.conversation_id == ^conversation_id,
    order_by: [desc: i.inserted_at],
    limit: 1,
    preload: [:created_by]
  )
  |> Repo.one()
end

def is_invite_valid?(invite) do
  cond do
    is_nil(invite) -> false
    invite.expires_at && DateTime.compare(DateTime.utc_now(), invite.expires_at) == :gt -> false
    invite.max_uses && invite.use_count >= invite.max_uses -> false
    true -> true
  end
end

def use_invite(token, user_id) do
  invite = get_invite_by_token(token)

  cond do
    !is_invite_valid?(invite) ->
      {:error, :invalid_invite}

    member?(invite.conversation_id, user_id) ->
      {:error, :already_member}

    true ->
      # Add user to group
      case add_member_to_group(invite.conversation_id, user_id) do
        {:ok, member} ->
          # Increment use count
          invite
          |> GroupInvite.changeset(%{use_count: invite.use_count + 1})
          |> Repo.update()

          # Broadcast member added
          broadcast_member_added(invite.conversation_id, member)
          {:ok, invite.conversation}

        error ->
          error
      end
  end
end

def revoke_invite(conversation_id, user_id) do
  if member?(conversation_id, user_id) do
    from(i in GroupInvite, where: i.conversation_id == ^conversation_id)
    |> Repo.delete_all()
    :ok
  else
    {:error, :not_a_member}
  end
end

defp revoke_existing_invite(conversation_id) do
  from(i in GroupInvite, where: i.conversation_id == ^conversation_id)
  |> Repo.delete_all()
end
```

### JoinGroupLive
```elixir
defmodule ElixirchatWeb.JoinGroupLive do
  use ElixirchatWeb, :live_view

  alias Elixirchat.Chat

  def mount(%{"token" => token}, _session, socket) do
    invite = Chat.get_invite_by_token(token)

    cond do
      is_nil(invite) ->
        {:ok,
         socket
         |> put_flash(:error, "Invalid invite link")
         |> assign(invite: nil, valid: false)}

      !Chat.is_invite_valid?(invite) ->
        {:ok,
         socket
         |> put_flash(:error, "This invite link has expired or reached its limit")
         |> assign(invite: invite, valid: false)}

      true ->
        member_count = Chat.get_member_count(invite.conversation_id)
        already_member = socket.assigns[:current_user] && Chat.member?(invite.conversation_id, socket.assigns.current_user.id)

        {:ok,
         socket
         |> assign(
           invite: invite,
           valid: true,
           member_count: member_count,
           already_member: already_member
         )}
    end
  end

  def handle_event("join_group", _, socket) do
    case Chat.use_invite(socket.assigns.invite.token, socket.assigns.current_user.id) do
      {:ok, conversation} ->
        {:noreply,
         socket
         |> put_flash(:info, "You joined #{conversation.name}!")
         |> push_navigate(to: ~p"/chat/#{conversation.id}")}

      {:error, :already_member} ->
        {:noreply,
         socket
         |> push_navigate(to: ~p"/chat/#{socket.assigns.invite.conversation_id}")}

      {:error, _} ->
        {:noreply, put_flash(socket, :error, "Could not join group")}
    end
  end

  def render(assigns) do
    ~H"""
    <div class="min-h-screen flex items-center justify-center bg-base-200 p-4">
      <div class="card bg-base-100 shadow-xl max-w-md w-full">
        <div class="card-body text-center">
          <%= if @valid do %>
            <h2 class="card-title justify-center text-2xl mb-2">
              Join {@invite.conversation.name}
            </h2>
            <p class="text-base-content/60 mb-4">
              {@member_count} members
            </p>

            <%= if @current_user do %>
              <%= if @already_member do %>
                <p class="mb-4">You're already a member of this group.</p>
                <.link navigate={~p"/chat/#{@invite.conversation_id}"} class="btn btn-primary">
                  Go to Chat
                </.link>
              <% else %>
                <button phx-click="join_group" class="btn btn-primary btn-lg">
                  Join Group
                </button>
              <% end %>
            <% else %>
              <p class="mb-4">Please log in to join this group.</p>
              <.link navigate={~p"/login?redirect=/join/#{@invite.token}"} class="btn btn-primary">
                Log in to Join
              </.link>
            <% end %>
          <% else %>
            <div class="text-error mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 mx-auto mb-4">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z" />
              </svg>
              <h2 class="card-title justify-center">Invalid Invite</h2>
              <p>This invite link is invalid, expired, or has reached its maximum uses.</p>
            </div>
            <.link navigate={~p"/chat"} class="btn btn-ghost">
              Go to Chat
            </.link>
          <% end %>
        </div>
      </div>
    </div>
    """
  end
end
```

### UI - Invite Link Modal in ChatLive
```heex
<%!-- Invite link button in group chat header --%>
<button
  :if={@conversation.type == "group" && !@conversation.is_general}
  phx-click="show_invite_modal"
  class="btn btn-ghost btn-sm"
  title="Get invite link"
>
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
    <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" />
  </svg>
</button>

<%!-- Invite link modal --%>
<div :if={@show_invite_modal} class="modal modal-open">
  <div class="modal-box">
    <h3 class="font-bold text-lg mb-4">Invite Link</h3>

    <div :if={@invite_link} class="space-y-4">
      <div class="flex gap-2">
        <input
          type="text"
          value={@invite_link}
          readonly
          class="input input-bordered flex-1 font-mono text-sm"
          id="invite-link-input"
        />
        <button
          phx-click={JS.dispatch("phx:copy", to: "#invite-link-input")}
          class="btn btn-primary"
        >
          Copy
        </button>
      </div>

      <p class="text-sm text-base-content/60">
        Share this link with others to invite them to the group.
      </p>

      <button phx-click="regenerate_invite" class="btn btn-ghost btn-sm">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 mr-1">
          <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
        </svg>
        Regenerate Link
      </button>
    </div>

    <div :if={!@invite_link}>
      <p class="text-base-content/60 mb-4">No active invite link. Create one to invite others.</p>
      <button phx-click="create_invite" class="btn btn-primary">
        Create Invite Link
      </button>
    </div>

    <div class="modal-action">
      <button phx-click="close_invite_modal" class="btn btn-ghost">Close</button>
    </div>
  </div>
  <div class="modal-backdrop bg-base-content/50" phx-click="close_invite_modal"></div>
</div>
```

### Event Handlers for ChatLive
```elixir
def handle_event("show_invite_modal", _, socket) do
  invite = Chat.get_group_invite(socket.assigns.conversation.id)
  invite_link = if invite && Chat.is_invite_valid?(invite) do
    url(~p"/join/#{invite.token}")
  end

  {:noreply, assign(socket, show_invite_modal: true, invite_link: invite_link)}
end

def handle_event("close_invite_modal", _, socket) do
  {:noreply, assign(socket, show_invite_modal: false)}
end

def handle_event("create_invite", _, socket) do
  case Chat.create_group_invite(socket.assigns.conversation.id, socket.assigns.current_user.id) do
    {:ok, invite} ->
      invite_link = url(~p"/join/#{invite.token}")
      {:noreply,
       socket
       |> assign(invite_link: invite_link)
       |> put_flash(:info, "Invite link created")}

    {:error, _} ->
      {:noreply, put_flash(socket, :error, "Could not create invite")}
  end
end

def handle_event("regenerate_invite", _, socket) do
  # Revoke existing and create new
  Chat.revoke_invite(socket.assigns.conversation.id, socket.assigns.current_user.id)

  case Chat.create_group_invite(socket.assigns.conversation.id, socket.assigns.current_user.id) do
    {:ok, invite} ->
      invite_link = url(~p"/join/#{invite.token}")
      {:noreply,
       socket
       |> assign(invite_link: invite_link)
       |> put_flash(:info, "New invite link generated")}

    {:error, _} ->
      {:noreply, put_flash(socket, :error, "Could not regenerate invite")}
  end
end
```

### JavaScript Hook for Copy
```javascript
// In app.js hooks
Hooks.CopyToClipboard = {
  mounted() {
    this.el.addEventListener("phx:copy", (e) => {
      const input = document.getElementById("invite-link-input")
      navigator.clipboard.writeText(input.value)
        .then(() => {
          // Optional: show toast/feedback
        })
    })
  }
}
```

## Acceptance Criteria
- [ ] Group members can create an invite link for their group
- [ ] Invite link is displayed in a modal with copy button
- [ ] Clicking invite link shows group info and "Join" button
- [ ] Joining via link adds user to group and redirects to chat
- [ ] Users already in the group see "Go to Chat" instead
- [ ] Non-logged-in users are prompted to log in first
- [ ] Invalid/expired links show appropriate error
- [ ] Links can be regenerated (old link becomes invalid)
- [ ] General group does not have invite link option
- [ ] Invite links work correctly after page refresh

## Dependencies
- Task 004: Group Chat System (completed)

## Testing Notes
- Create a group and generate an invite link
- Open link in incognito/different browser
- Join the group via the link
- Verify you're redirected to the group chat
- Try the same link again (should show "already member")
- Regenerate the link and verify old link no longer works
- Test with logged-out user (should prompt to login)
- Test invalid/random token (should show error)
- Verify General group has no invite option

## Edge Cases to Handle
- User tries to create invite for non-group conversation
- User not a member tries to create invite
- Same user clicks link multiple times
- User joins via link while already logged in to a different conversation
- Invite link created but group is deleted
- Creator leaves group (invite should still work)
- Very high use_count (integer overflow protection)
- Concurrent join attempts

## Future Enhancements (not in this task)
- Invite link with expiration time picker
- Invite link with max uses limit
- QR code generation for invite link
- Admin-only invite creation setting
- Invite link analytics (who joined via which link)
- Temporary/one-time use invite links
- Approval workflow (request to join)
